# Program: BLE_Calibrator.py
# Purpose: Guided calibration tool for BLE iBeacon proximity detection.
#          Collects RSSI data at known distances, calculates optimal parameters,
#          and exports them for use in the main door opener system.
# Author: Dr. Ralf Korell 
# Creation Date: August 16, 2025
# Modified: August 16, 2025 - Initial implementation based on agreed plan.
# Corrected: August 16, 2025, 21:30 UTC - Fixed Tkinter/Asyncio integration (RuntimeError: Calling Tcl from different apartment).
#            Tkinter now runs in the main thread, asyncio loop is periodically updated via root.after().
# Corrected: August 16, 2025, 21:45 UTC - Fixed AttributeError: '_start_async_tasks_and_periodic_update' not found.
#            Ensured thread-safe logging to GUI by using root.after() for all GUI updates from TextHandler.
# Corrected: August 16, 2025, 22:00 UTC - Added Minor value to live data display in GUI.
# Corrected: August 16, 2025, 22:15 UTC - Implemented clean shutdown for Tkinter and asyncio.
#            Handles window close event (WM_DELETE_WINDOW) to stop all tasks gracefully.
# Corrected: August 16, 2025, 22:30 UTC - Fixed AttributeError: 'on_closing' not found by encapsulating cleanup logic within BLECalibratorGUI class.
# Corrected: August 16, 2025, 22:45 UTC - Implemented robust shutdown mechanism using root.quit() and post-mainloop asyncio cleanup.

import asyncio
import time
import os
import csv
import json
import tkinter as tk
from tkinter import ttk, scrolledtext
import logging
import statistics # For standard deviation
import numpy as np # For linear regression
import math # For log10

# BLE Imports
from bleak import BleakScanner
import struct

# --- Logging Konfiguration für den Kalibrator ---
# Log-Meldungen werden sowohl in die Konsole als auch in das GUI-Textfeld geschrieben.

class GuiLogHandler(logging.Handler):
    def __init__(self, text_widget, root_widget):
        super().__init__()
        self.text_widget = text_widget
        self.root_widget = root_widget

    def emit(self, record):
        msg = self.format(record)
        # Corrected: Check if widget still exists before trying to update
        if self.text_widget.winfo_exists():
            # Schedule the GUI update to run in the main Tkinter thread
            self.root_widget.after(0, self._update_text_widget, msg)

    def _update_text_widget(self, msg):
        # Corrected: Final check within the scheduled call
        if self.text_widget.winfo_exists():
            self.text_widget.config(state='normal')
            self.text_widget.insert(tk.END, msg + "\n")
            self.text_widget.see(tk.END)
            self.text_widget.config(state='disabled')

logging.basicConfig(level=logging.INFO, format='%(asctime)s - BLE - %(levelname)s - %(message)s')
# Konsolen-Handler hinzufügen (falls nicht schon durch basicConfig geschehen)
console_handler = logging.StreamHandler()
console_handler.setFormatter(logging.Formatter('%(asctime)s - BLE - %(levelname)s - %(message)s'))
logging.getLogger().addHandler(console_handler)

# --- Globale Variablen für den BLE Scan ---
# beacon_last_seen_data is still global as it's modified by the Bleak callback
beacon_last_seen_data = {} 
current_calibration_data_buffer = [] # Buffer for data collected during one measurement phase

# --- KONFIGURATION (kopiert und angepasst aus tueroeffner.py) ---
# Diese Werte können im Code angepasst werden.

# BLE iBeacon Konfiguration
TARGET_IBEACON_UUID = "E2C56DB5-DFFB-48D2-B060-D0F5A71096E0" # UUID ist für alle Minew Beacons identisch
CALIBRATED_MEASURED_POWER_DEFAULT = -77 # Kalibrierter Measured Power (Tx Power @ 1m vom Beacon)
PATH_LOSS_EXPONENT_DEFAULT = 2.5 # Pfadverlust-Exponent (N): Typischerweise 2.0 für freie Sicht, 2.5-4.0 für Innenräume.

# Proximity und Debouncing Konfiguration (für Triggerung der Kamera im Calibrator)
PROXIMITY_DISTANCE_THRESHOLD = 3.0 # Meter: Distanz-Schwellenwert für "nah genug"
PRESENCE_DETECTION_TIME = 3 # Sekunden: Zeit, die der Beacon kontinuierlich erkannt werden muss, um als "anwesend" zu gelten
ABSENCE_DETECTION_TIME = 10 # Sekunden: Zeit, die der Beacon nicht erkannt werden darf, um als "nicht anwesend" zu gelten

# Konfigurationsdatei für erlaubte Nutzer und deren Beacons (für allowed_majors)
ALLOWED_USERS_CONFIG = "Erlaubte_Nutzer.conf"

# Kalibrierungsspezifische Konfiguration
CALIBRATION_DISTANCES = [
    # Annäherung 1: Start bei 5m, engere Schritte im Nahbereich
    5.0, 4.5, 4.0, 3.5, 3.0, 2.5, 2.0, 1.75, 1.5, 1.25, 1.0, 0.75, 0.5, 0.25,
    # Entfernung 1: Rückweg
    0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0,
    # Annäherung 2: Start bei 4m, engere Schritte im Nahbereich
    4.0, 3.5, 3.0, 2.5, 2.0, 1.75, 1.5, 1.25, 1.0, 0.75, 0.5, 0.25
]
PRE_MEASUREMENT_DELAY_SEC = 5 # Sekunden Countdown vor jeder Messphase
MEASUREMENT_DURATION_SEC = 15 # Sekunden Dauer der Datensammlung pro Abstand
BLE_SCAN_INTERVAL_SEC = 1.0 # Sekunden Intervall für den BLE-Scan

# --- Hilfsfunktionen (kopiert aus tueroeffner.py) ---

def cleanup_gpio():
    """Räumt die GPIO-Einstellungen auf."""
    try:
        import RPi.GPIO as GPIO
        if GPIO.getmode() is not None:
            GPIO.cleanup()
            logging.info("GPIO aufgeräumt.")
    except ImportError:
        logging.warning("RPi.GPIO nicht importierbar, überspringe GPIO-Cleanup.")

def bytes_to_uuid(b):
    return f"{b[0:4].hex()}-{b[4:6].hex()}-{b[6:8].hex()}-{b[8:10].hex()}-{b[10:16].hex()}".upper()

def estimate_distance(rssi, measured_power, n):
    if rssi == 0:
        return -1.0
    return 10 ** ((measured_power - rssi) / (10 * n))

def read_allowed_users_config():
    """
    Liest die Konfigurationsdatei für erlaubte Nutzer und ihre Beacon-Majors ein.
    Format: Name;wahr/falsch;Major1;Major2;Major3
    """
    allowed_users = {}
    script_dir = os.path.dirname(os.path.abspath(__file__))
    config_path = os.path.join(script_dir, ALLOWED_USERS_CONFIG)

    if os.path.exists(config_path):
        try:
            with open(config_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith('#'): # Kommentare und leere Zeilen ignorieren
                        continue
                    
                    parts = line.split(';')
                    if len(parts) < 2:
                        logging.warning(f"Ungültige Zeile in '{ALLOWED_USERS_CONFIG}': '{line}'. Erwarte mindestens Name;Status.")
                        continue
                    
                    name = parts[0].strip()
                    status_str = parts[1].strip().lower()
                    allowed = (status_str == 'wahr')
                    
                    beacon_majors = []
                    # Lese Major-Werte ab dem dritten Feld
                    for i in range(2, len(parts)):
                        major_str = parts[i].strip()
                        if major_str:
                            try:
                                beacon_majors.append(int(major_str))
                            except ValueError:
                                logging.warning(f"Ungültiger Major-Wert '{major_str}' für Nutzer '{name}' in '{ALLOWED_USERS_CONFIG}'. Ignoriere.")
                    
                    allowed_users[name] = {
                        'allowed': allowed,
                        'beacon_majors': beacon_majors
                    }
        except Exception as e:
            logging.error(f"Fehler beim Lesen von '{ALLOWED_USERS_CONFIG}': {e}")
    return allowed_users

# --- GUI-Klasse ---
class BLECalibratorGUI:
    def __init__(self, root, loop):
        self.root = root
        self.loop = loop # The asyncio event loop
        self.root.title("BLE Kalibrator")
        self.root.geometry("800x700")

        self.all_calibration_data = [] # List to store all collected data points
        # Corrected: Make these instance attributes
        self.ble_scan_active = False 
        self.calibration_running = False 

        self.current_beacon_is_present = False # To track beacon presence for camera trigger simulation
        self.last_beacon_state_change_time = time.time() # For debouncing
        self.allowed_majors = self._get_allowed_majors()

        self._create_widgets()
        self._setup_logging_to_gui()

        # Corrected: Bind the window close event to our cleanup function
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

        # Start the BLE scan task immediately when the GUI is initialized
        self.ble_scan_task = self.loop.create_task(self._run_ble_scan_task())
        logging.info("BLE Scan Task gestartet.")

        # Corrected: Start the periodic asyncio runner
        self._periodic_asyncio_run_id = self.root.after(10, self._periodic_asyncio_run)


    def _get_allowed_majors(self):
        allowed_users_data = read_allowed_users_config()
        majors = set()
        for user_data in allowed_users_data.values():
            if user_data['allowed']:
                majors.update(user_data['beacon_majors'])
        logging.info(f"Erlaubte Major-Werte für BLE-Filterung: {majors}")
        return majors

    def _create_widgets(self):
        # Frame for controls
        control_frame = ttk.LabelFrame(self.root, text="Steuerung")
        control_frame.pack(padx=10, pady=10, fill="x")

        self.start_button = ttk.Button(control_frame, text="Start BLE Kalibrierung (Geführt)", command=self.start_calibration)
        self.start_button.pack(side="left", padx=5, pady=5)

        self.stop_button = ttk.Button(control_frame, text="Stop BLE Kalibrierung", command=self.stop_calibration)
        self.stop_button.pack(side="left", padx=5, pady=5)
        self.stop_button.config(state="disabled")

        # Frame for status
        status_frame = ttk.LabelFrame(self.root, text="Status & Anweisung")
        status_frame.pack(padx=10, pady=10, fill="x")

        self.status_canvas = tk.Canvas(status_frame, width=150, height=150, bg="white")
        self.status_canvas.pack(side="left", padx=10, pady=10)
        self.status_circle = self.status_canvas.create_oval(10, 10, 140, 140, fill="gray", outline="black")
        # Main text for distance, larger font
        self.status_text_main = self.status_canvas.create_text(75, 65, text="Bereit", font=("Arial", 36, "bold"), fill="black", justify="center")
        # Sub text for countdown, smaller font
        self.status_text_sub = self.status_canvas.create_text(75, 110, text="", font=("Arial", 16), fill="black", justify="center")
        
        self.instruction_label = ttk.Label(status_frame, text="Drücken Sie 'Start' um die Kalibrierung zu beginnen.", wraplength=500)
        self.instruction_label.pack(side="left", padx=10, pady=10, fill="both", expand=True)

        # Frame for raw data display (for debugging/overview)
        data_frame = ttk.LabelFrame(self.root, text="Erkannte Beacons (Live)")
        data_frame.pack(padx=10, pady=10, fill="both", expand=True)

        self.data_listbox = scrolledtext.ScrolledText(data_frame, height=5, state='disabled')
        self.data_listbox.pack(padx=5, pady=5, fill="both", expand=True)

        # Frame for log output
        log_frame = ttk.LabelFrame(self.root, text="Log-Ausgabe")
        log_frame.pack(padx=10, pady=10, fill="both", expand=True)

        self.log_text = scrolledtext.ScrolledText(log_frame, height=15, state='disabled')
        self.log_text.pack(padx=5, pady=5, fill="both", expand=True)

    def _setup_logging_to_gui(self):
        # Create a local handler that knows about self.log_text and self.root
        gui_handler = GuiLogHandler(self.log_text, self.root)
        gui_handler.setFormatter(logging.Formatter('%(asctime)s - BLE - %(levelname)s - %(message)s'))
        logging.getLogger().addHandler(gui_handler)
        # Initial message to GUI log
        self.log_text.config(state='normal')
        self.log_text.insert(tk.END, "GUI-Logging gestartet.\n")
        self.log_text.config(state='disabled')

    def update_status_display(self, color, main_text, sub_text=""):
        self.status_canvas.itemconfig(self.status_circle, fill=color)
        self.status_canvas.itemconfig(self.status_text_main, text=main_text)
        self.status_canvas.itemconfig(self.status_text_sub, text=sub_text)
        self.root.update_idletasks() # Force GUI update

    async def _run_ble_scan_task(self):
        # Corrected: Use instance attribute
        self.ble_scan_active = True 
        logging.info("BLE Scan Task gestartet.")

        def detection_callback(device, advertisement_data):
            rssi_val = advertisement_data.rssi
            
            if 0x004C in advertisement_data.manufacturer_data:
                mfg_data = advertisement_data.manufacturer_data[0x004C]
                
                if len(mfg_data) >= 23 and mfg_data[0] == 0x02 and mfg_data[1] == 0x15:
                    try:
                        uuid_bytes, major_val, minor_val, measured_power = struct.unpack_from(">16sHHb", mfg_data, 2)
                    except struct.error:
                        return

                    uuid_str = bytes_to_uuid(uuid_bytes)

                    if uuid_str == TARGET_IBEACON_UUID and major_val in self.allowed_majors:
                        distance = estimate_distance(rssi_val, CALIBRATED_MEASURED_POWER_DEFAULT, PATH_LOSS_EXPONENT_DEFAULT)
                        
                        beacon_info = {
                            'timestamp': time.time(),
                            'mac': device.address,
                            'major': major_val,
                            'minor': minor_val,
                            'rssi': rssi_val,
                            'distance': distance
                        }
                        beacon_last_seen_data[device.address] = beacon_info

                        # Update GUI data listbox from the main thread
                        self.root.after(0, self._update_data_listbox, beacon_info)

                        # If calibration is running, add data to buffer
                        # Corrected: Use instance attribute
                        if self.calibration_running:
                            # This append is safe as current_calibration_data_buffer is a simple list
                            self.loop.call_soon_threadsafe(current_calibration_data_buffer.append, beacon_info) # Ensure thread-safety for shared list

        scanner = BleakScanner(detection_callback=detection_callback)
        await scanner.start()
        
        # Corrected: Use instance attribute
        while self.ble_scan_active: 
            current_time = time.time()
            addresses_to_remove = [
                addr for addr, data in beacon_last_seen_data.items()
                if current_time - data['timestamp'] > ABSENCE_DETECTION_TIME
            ]
            for addr in addresses_to_remove:
                del beacon_last_seen_data[addr]
                logging.info(f"Beacon {addr} aus Liste entfernt (zu alt oder zu weit weg).")

            await asyncio.sleep(BLE_SCAN_INTERVAL_SEC)
        
        await scanner.stop()
        logging.info("BLE Scan Task gestoppt.")

    def _update_data_listbox(self, beacon_info):
        self.data_listbox.config(state='normal')
        # Corrected: Added Minor value to display
        self.data_listbox.insert(tk.END, f"MAC: {beacon_info['mac']}, Major: {beacon_info['major']}, Minor: {beacon_info['minor']}, RSSI: {beacon_info['rssi']} dBm, Distanz: {beacon_info['distance']:.2f}m\n")
        self.data_listbox.see(tk.END)
        self.data_listbox.config(state='disabled')

    def start_calibration(self):
        # Corrected: Use instance attribute
        if self.calibration_running:
            logging.warning("Kalibrierung läuft bereits.")
            return

        self.start_button.config(state="disabled")
        self.stop_button.config(state="normal")
        # Corrected: Use instance attribute
        self.calibration_running = True 
        self.all_calibration_data = [] # Clear previous data
        logging.info("Geführte BLE Kalibrierung gestartet.")
        # Schedule the async workflow as an asyncio task
        self.loop.create_task(self._guided_calibration_workflow())

    def stop_calibration(self):
        # Corrected: Use instance attribute
        if not self.calibration_running:
            logging.warning("Keine Kalibrierung läuft.")
            return
        
        # Corrected: Use instance attribute
        self.calibration_running = False 
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")
        self.update_status_display("red", "Abgebrochen!")
        self.instruction_label.config(text="Kalibrierung manuell abgebrochen.")
        logging.info("Geführte BLE Kalibrierung abgebrochen.")

    async def _guided_calibration_workflow(self):
        # Corrected: Use instance attribute
        try:
            for i, target_distance in enumerate(CALIBRATION_DISTANCES):
                if not self.calibration_running: break # Use instance flag for workflow control

                self.instruction_label.config(text=f"Stellen Sie sich auf {target_distance:.1f} Meter Entfernung.")
                logging.info(f"Nächster Messpunkt: {target_distance:.1f} Meter.")
                
                # Countdown phase (Yellow)
                for count in range(PRE_MEASUREMENT_DELAY_SEC, 0, -1):
                    if not self.calibration_running: break
                    # Corrected: Display distance large, countdown small
                    self.update_status_display("yellow", f"{target_distance:.1f}m", f"Countdown: {count}")
                    await asyncio.sleep(1)
                if not self.calibration_running: break

                # Measurement phase (Green)
                self.instruction_label.config(text=f"Messe bei {target_distance:.1f} Meter. Bewegen Sie sich leicht.")
                logging.info(f"Starte Messung bei {target_distance:.1f} Meter für {MEASUREMENT_DURATION_SEC} Sekunden.")
                self.update_status_display("green", f"{target_distance:.1f}m", "Messe...")
                
                current_calibration_data_buffer.clear() # Clear buffer for this measurement
                measurement_start_time = time.time()
                while time.time() - measurement_start_time < MEASUREMENT_DURATION_SEC:
                    if not self.calibration_running: break
                    await asyncio.sleep(0.1) # Small sleep to allow data collection

                # Process collected data for this phase
                if current_calibration_data_buffer:
                    # Group data by beacon (MAC, Major, Minor)
                    grouped_data = {}
                    for beacon_info in current_calibration_data_buffer:
                        beacon_id = (beacon_info['mac'], beacon_info['major'], beacon_info['minor'])
                        if beacon_id not in grouped_data:
                            grouped_data[beacon_id] = []
                        grouped_data[beacon_id].append(beacon_info['rssi'])
                    
                    for (mac, major, minor), rssi_values in grouped_data.items():
                        if len(rssi_values) > 1: # Need at least 2 points for std dev
                            rssi_std_dev = statistics.stdev(rssi_values)
                        else:
                            rssi_std_dev = 0.0 # No std dev for single or no value

                        # Average RSSI for this measurement phase
                        avg_rssi = statistics.mean(rssi_values) if rssi_values else 0
                        avg_distance = estimate_distance(avg_rssi, CALIBRATED_MEASURED_POWER_DEFAULT, PATH_LOSS_EXPONENT_DEFAULT)

                        self.all_calibration_data.append({
                            'Timestamp': time.time(),
                            'Beacon_Address': mac,
                            'Beacon_Major': major,
                            'Beacon_Minor': minor,
                            'RSSI_Value': avg_rssi, # Store average RSSI for this measurement phase
                            'Calculated_Distance': avg_distance,
                            'Actual_Distance_Provided': target_distance,
                            'RSSI_StdDev_During_Measurement': rssi_std_dev,
                            'Num_Packets_Received_During_Measurement': len(rssi_values)
                        })
                        logging.info(f"Gesammelte Daten für {mac}/{major}/{minor} bei {target_distance:.1f}m: Avg RSSI={avg_rssi:.2f}, StdDev={rssi_std_dev:.2f}, Pakete={len(rssi_values)}")
                else:
                    logging.warning(f"Keine Beacon-Daten bei {target_distance:.1f}m gesammelt. Beacon nicht in Reichweite?")

            # Calibration finished successfully
            # Corrected: Use instance attribute
            self.calibration_running = False 
            self.start_button.config(state="normal")
            self.stop_button.config(state="disabled")
            self.update_status_display("gray", "Fertig!")
            self.instruction_label.config(text="Kalibrierung abgeschlossen. Berechne und exportiere Parameter...")
            logging.info("Geführte BLE Kalibrierung erfolgreich abgeschlossen.")
            
            # Automatically calculate and export parameters
            self._calculate_and_export_parameters()

        except asyncio.CancelledError:
            logging.info("Kalibrierungs-Workflow abgebrochen.")
        except Exception as e:
            logging.error(f"Fehler im Kalibrierungs-Workflow: {e}", exc_info=True)
            self.update_status_display("red", "Fehler!")
            self.instruction_label.config(text=f"FEHLER: {e}")
            # Corrected: Use instance attribute
            self.stop_calibration() 

    def _calculate_and_export_parameters(self):
        logging.info("Starte Parameterberechnung und Export.")
        
        # Group data by unique beacon (MAC, Major, Minor)
        grouped_beacons_data = {}
        for data_point in self.all_calibration_data:
            beacon_id = (data_point['Beacon_Address'], data_point['Beacon_Major'], data_point['Beacon_Minor'])
            if beacon_id not in grouped_beacons_data:
                grouped_beacons_data[beacon_id] = []
            grouped_beacons_data[beacon_id].append(data_point)

        calibrated_beacons = []
        for (mac, major, minor), data_points in grouped_beacons_data.items():
            rssi_values = [dp['RSSI_Value'] for dp in data_points]
            actual_distances = [dp['Actual_Distance_Provided'] for dp in data_points]

            if len(rssi_values) < 2:
                logging.warning(f"Nicht genug Datenpunkte für Beacon {mac}/{major}/{minor} zur Kalibrierung. Überspringe.")
                continue

            # Perform linear regression to find optimal measured_power and path_loss_exponent
            # Formula: RSSI = measured_power - 10 * n * log10(distance)
            # Rearrange to linear form: RSSI = A + B * log10(distance)
            # Where A = measured_power, B = -10 * n
            # So, n = -B / 10
            
            # Filter out distances <= 0 to avoid log(0)
            valid_data = [(r, d) for r, d in zip(rssi_values, actual_distances) if d > 0]
            if not valid_data:
                logging.warning(f"Keine gültigen Datenpunkte für Beacon {mac}/{major}/{minor} (Abstand <= 0). Überspringe.")
                continue

            rssi_for_reg = [item[0] for item in valid_data]
            log_distances = [10 * math.log10(item[1]) for item in valid_data] # Multiply by 10 for direct regression on -10n

            try:
                # Use numpy for linear regression
                # x = log_distances, y = rssi_for_reg
                A = np.vstack([log_distances, np.ones(len(log_distances))]).T
                m, c = np.linalg.lstsq(A, rssi_for_reg, rcond=None)[0]

                # m is -10 * n, c is measured_power
                calibrated_n = -m / 10
                calibrated_mp = c

                logging.info(f"Kalibrierte Parameter für Beacon {mac}/{major}/{minor}: Measured Power={calibrated_mp:.2f}, Path Loss Exponent={calibrated_n:.2f}")

                calibrated_beacons.append({
                    "major": major,
                    "minor": minor,
                    "mac_address": mac,
                    "calibrated_measured_power": round(calibrated_mp, 2),
                    "path_loss_exponent": round(calibrated_n, 2)
                })

            except Exception as e:
                logging.error(f"Fehler bei der Regression für Beacon {mac}/{major}/{minor}: {e}")

        # Export to JSON
        output_data = {
            "beacon_uuid": TARGET_IBEACON_UUID,
            "calibrated_beacons": calibrated_beacons,
            "global_defaults": {
                "calibrated_measured_power": CALIBRATED_MEASURED_POWER_DEFAULT,
                "path_loss_exponent": PATH_LOSS_EXPONENT_DEFAULT
            }
        }
        
        script_dir = os.path.dirname(os.path.abspath(__file__))
        json_output_path = os.path.join(script_dir, "beacon_calibration_params.json")
        csv_output_path = os.path.join(script_dir, f"ble_calibration_data_{int(time.time())}.csv")

        try:
            with open(json_output_path, 'w') as f:
                json.dump(output_data, f, indent=4)
            logging.info(f"Kalibrierte Parameter erfolgreich nach '{json_output_path}' exportiert.")

            # Also save raw data to CSV
            if self.all_calibration_data:
                with open(csv_output_path, 'w', newline='') as csvfile:
                    fieldnames = self.all_calibration_data[0].keys()
                    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(self.all_calibration_data)
                logging.info(f"Rohdaten erfolgreich nach '{csv_output_path}' exportiert.")

        except Exception as e:
            logging.error(f"Fehler beim Export der Kalibrierungsdaten: {e}")

    # Corrected: on_closing method is now part of the class
    def on_closing(self):
        logging.info("Tkinter Fenster geschlossen. Starte geordnetes Herunterfahren.")
        
        # Stop the periodic asyncio runner
        if self._periodic_asyncio_run_id:
            self.root.after_cancel(self._periodic_asyncio_run_id)
            self._periodic_asyncio_run_id = None # Clear the ID
            logging.info("Periodischer Asyncio Runner gestoppt.")

        # Set flag to stop BLE scan task
        self.ble_scan_active = False

        # Cancel all running asyncio tasks
        for task in asyncio.all_tasks(loop=self.loop):
            task.cancel()
        
        # Schedule the final cleanup in the asyncio loop
        self.loop.call_soon_threadsafe(self.loop.create_task, self._async_final_cleanup())
        
        # Finally, quit the Tkinter mainloop
        self.root.quit()

    # Corrected: Async final cleanup method
    async def _async_final_cleanup(self):
        logging.info("Starte asyncio Cleanup.")
        # Wait for all tasks to actually finish cancelling
        await asyncio.gather(*asyncio.all_tasks(loop=self.loop), return_exceptions=True)
        
        if not self.loop.is_closed():
            self.loop.close()
        logging.info("Asyncio Loop beendet.")
        cleanup_gpio()
        # No root.destroy() here, as root.quit() in on_closing handles the mainloop exit.
        # The mainloop will exit, and the code after root.mainloop() will then run.


    # Corrected: periodic_asyncio_run is now a method of the class
    def _periodic_asyncio_run(self):
        # Check if the loop is still running before trying to run it
        if not self.loop.is_running():
            try:
                # Run the loop for a very short period to process pending tasks
                self.loop.run_until_complete(asyncio.sleep(0))
            except RuntimeError: # Catch "Event loop is closed" or similar if cleanup already started
                return # Stop scheduling if loop is dead
        
        # Process any pending tasks in the asyncio loop
        self.loop._run_once() # Process one iteration of the event loop

        # Reschedule only if the root window still exists and we're not shutting down
        # Corrected: Added check for self.root.winfo_exists()
        if self.root.winfo_exists():
            self._periodic_asyncio_run_id = self.root.after(10, self._periodic_asyncio_run) # Schedule the next update after 10ms (faster updates)


# --- Hauptprogramm ---
def main():
    # Ensure multiprocessing is set to spawn for compatibility
    # This must be done at the very beginning of the main process
    import multiprocessing
    multiprocessing.set_start_method('spawn', force=True)

    root = tk.Tk()
    
    # Create the asyncio event loop and set it as the default for this thread
    # This is crucial for integrating with Tkinter's mainloop
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    app = BLECalibratorGUI(root, loop)

    # Start the Tkinter mainloop (this call is blocking)
    root.mainloop()

    # Code reaches here after root.quit() is called from on_closing
    logging.info("Programmende (nach Tkinter mainloop).") 
    # The actual asyncio cleanup is now handled by _async_final_cleanup
    # which is scheduled by on_closing. No direct asyncio cleanup needed here.


if __name__ == "__main__":
    main()