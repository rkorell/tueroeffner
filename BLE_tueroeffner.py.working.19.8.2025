# Program: BLE_tueroeffner.py
# Purpose: Automatisiertes Türöffnungssystem basierend auf Multi-Faktor BLE-Beacon-Identifikation.
#          Verwendet eine externe Konfigurationsdatei und steuert ein Display.
# Author: Dr. Ralf Korell / CircuIT
# Creation Date: August 18, 2025
# Modified: August 18, 2025 - Initial implementation based on multi-factor BLE identification,
#           system_config.json, and removal of camera functionality.
# Corrected: August 18, 2025, 10:30 UTC - Added missing read_system_config() function.
# Corrected: August 18, 2025, 10:45 UTC - Fixed NameError: 'atexit' not defined.
#            Implemented more robust asyncio and BleakScanner cleanup for clean exits.
# Corrected: August 18, 2025, 12:30 UTC - Fixed NameError: 'adafruit_sharpmemorydisplay' not defined.
# Corrected: August 18, 2025, 12:45 UTC - Refined cleanup logic to address multiple starts issue.
# Corrected: August 18, 2025, 13:00 UTC - Defined WEATHER_ICON_SIZE and CODESEND_MIN_DURATION_SEC,
#            and adjusted codesend duration validation.

import asyncio
import time
import os
import subprocess # Für den Aufruf von codesend
import json # For reading system_config.json
import struct # For BLE parsing
import atexit 

# BLE Imports
from bleak import BleakScanner

# Display Imports
import board
import busio
import digitalio
import logging
import datetime
from PIL import Image, ImageDraw, ImageFont, ImageOps
import requests
import adafruit_sharpmemorydisplay # Corrected: Added missing import

# --- GLOBALE KONFIGURATION (Wird aus system_config.json geladen) ---
# Default-Werte, falls system_config.json fehlt oder fehlerhaft ist
SYSTEM_CONFIG_FILE = "system_config.json"

# System Globals (Initialwerte, die aus der Konfigurationsdatei überschrieben werden)
TARGET_IBEACON_UUID = ""
EDDYSTONE_NAMESPACE_ID = ""
BLE_SCAN_INTERVAL_SEC = 1.0
IDENTIFICATION_TIMEOUT_SEC = 4.0
PROXIMITY_DISTANCE_THRESHOLD = 3.0
PRESENCE_DETECTION_TIME = 3
ABSENCE_DETECTION_TIME = 10
CALIBRATED_MEASURED_POWER_GLOBAL_DEFAULT = -77
PATH_LOSS_EXPONENT_GLOBAL_DEFAULT = 2.5
RELAY_ACTIVATION_DURATION_SEC = 4
FORCE_BEACON_ABSENCE_DURATION_SEC = 10
MIN_DETECTION_INTERVAL = 5 # Cooldown for codesend

# Weather Config (Initialwerte)
PWS_STATION_ID = ""
PWS_API_KEY = ""
PWS_QUERY_URL = "" # Will be constructed later
PWS_QUERY_INTERVAL_SEC = 5 * 60

# Logging Config (Initialwerte)
LOG_LEVEL = logging.INFO
LOG_FILE_ENABLED = False
LOG_FILE_PATH = "tuer_oeffner.log"

# codesend Konfiguration (hardkodiert, da nicht in JSON ausgelagert)
CODESEND_PATH = "/usr/local/bin/codesend"
CODESEND_CODE_BASIS = 1008
CODESEND_MIN_DURATION_SEC = 3 # NEU: Definierte Mindestdauer für codesend

# --- Globale Status-Queues und Variablen ---
display_status_queue = asyncio.Queue()

beacon_last_seen_data = {} # Stores for each Beacon: {'timestamp': time.time(), 'major': major_val, 'rssi': rssi_val, 'distance': distance}
beacon_is_present = False # True, wenn mindestens ein relevanter Beacon als "anwesend" gilt (nach Debouncing)

last_door_opened_timestamp = 0 

# Global state to track identification progress for each beacon MAC
# { "MAC_ADDRESS": { "name": "Beacon Name", "is_allowed": true/false,
#                    "ibeacon_data": {}, "uid_data": {}, "url_data": "",
#                    "last_packet_time": float, "is_fully_identified": bool,
#                    "known_beacon_config": {} } }
beacon_identification_state = {} 

# Loaded config from JSON
SYSTEM_CONFIG = None

# --- Display Konfiguration (hardkodiert, da nicht in JSON ausgelagert) ---
DISPLAY_WIDTH = 400
DISPLAY_HEIGHT = 240
SHARP_CS_PIN = board.D6
SHARP_EXTCOMIN_PIN = board.D5
SHARP_DISP_PIN = board.D22

# NEU: Definition der WEATHER_ICON_SIZE
WEATHER_ICON_SIZE = (20, 20)
ICON_DIMENSIONS = (32, 32) # Annahme für ICON_KEY

# --- Globale Display Instanzen (für cleanup) ---
display = None
cs = None
extcomin = None
disp = None
extcomin_running = False # Flag, um den EXTCOMIN-Toggle-Thread zu steuern

# --- Globale Icon Variablen ---
# ICON_EYE wird nicht mehr verwendet
ICON_KEY = None
ICON_WIND = None
ICON_RAIN = None

# Globale Variable für die zuletzt erfolgreich abgerufenen Wetterdaten
last_successful_weather_data = {
    "temperature": "N/A",
    "wind_direction": "N/A",
    "wind_speed": "N/A",
    "precipitation": "N/A",
    "is_cached": True # Initial als "cached" markieren
}
last_pws_query_time = 0 # Initialisiere hier, damit es nicht in der Funktion als global deklariert werden muss

# --- Hilfsfunktionen ---

# NEU: read_system_config Funktion
def read_system_config():
    """
    Liest die Systemkonfigurationsdatei (system_config.json).
    """
    script_dir = os.path.dirname(os.path.abspath(__file__))
    config_path = os.path.join(script_dir, SYSTEM_CONFIG_FILE)

    if os.path.exists(config_path):
        try:
            with open(config_path, 'r') as f:
                config = json.load(f)
                logging.info(f"MAIN: Systemkonfiguration aus '{SYSTEM_CONFIG_FILE}' geladen.")
                return config
        except Exception as e:
            logging.error(f"MAIN: Fehler beim Laden von '{SYSTEM_CONFIG_FILE}': {e}")
            return None
    else:
        logging.error(f"MAIN: Systemkonfigurationsdatei '{SYSTEM_CONFIG_FILE}' nicht gefunden.")
        return None

def cleanup_gpio():
    """Räumt die GPIO-Einstellungen auf."""
    try:
        import RPi.GPIO as GPIO
        if GPIO.getmode() is not None:
            GPIO.cleanup()
            logging.info("MAIN: RPi.GPIO aufgeräumt.")
    except ImportError:
        logging.warning("MAIN: RPi.GPIO nicht importierbar, überspringe GPIO-Cleanup.")

atexit.register(cleanup_gpio)

# --- codesend Hilfsfunktion ---
_last_codesend_time = 0
async def send_door_open_command(duration_sec):
    """
    Berechnet den codesend-Code basierend auf der gewünschten Dauer und ruft codesend auf.
    Verhindert Mehrfachauslösung innerhalb von MIN_DETECTION_INTERVAL.
    """
    global _last_codesend_time
    current_time = time.time()

    if (current_time - _last_codesend_time) < SYSTEM_CONFIG["system_globals"]["min_detection_interval"]:
        logging.info(f"MAIN: codesend Cooldown aktiv. Nächste Auslösung in {SYSTEM_CONFIG['system_globals']['min_detection_interval'] - (current_time - _last_codesend_time):.1f}s.")
        return

    # KORREKTUR: Verwende CODESEND_MIN_DURATION_SEC für die untere Grenze
    if not (CODESEND_MIN_DURATION_SEC <= duration_sec <= 10):
        logging.error(f"MAIN: Ungültige Dauer für codesend: {duration_sec} Sekunden. Muss zwischen {CODESEND_MIN_DURATION_SEC} und 10 Sekunden liegen.")
        return

    code_to_send = CODESEND_CODE_BASIS + (duration_sec - CODESEND_MIN_DURATION_SEC)
    
    try:
        logging.info(f"MAIN: Sende Türöffner-Befehl: codesend {code_to_send}")
        process = await asyncio.to_thread(
            subprocess.run,
            [CODESEND_PATH, str(code_to_send)],
            check=True,
            capture_output=True,
            text=True
        )
        logging.info(f"MAIN: codesend erfolgreich aufgerufen. Output: {process.stdout.strip()}")
        _last_codesend_time = current_time
    except FileNotFoundError:
        logging.error(f"MAIN: Fehler: codesend nicht gefunden unter {CODESEND_PATH}. Bitte Pfad prüfen.")
    except subprocess.CalledProcessError as e:
        logging.error(f"MAIN: Fehler beim Aufruf von codesend: {e}. Stdout: {e.stdout}, Stderr: {e.stderr}")
    except Exception as e:
        logging.error(f"MAIN: Ein unerwarteter Fehler beim Senden des codesend-Befehls ist aufgetreten: {e}")

# --- BLE Hilfsfunktionen ---
def bytes_to_uuid(b):
    if len(b) != 16:
        logging.warning(f"BLE: UUID bytes have incorrect length: {len(b)}. Expected 16.")
        return None
    return f"{b[0:4].hex()}-{b[4:6].hex()}-{b[6:8].hex()}-{b[8:10].hex()}-{b[10:16].hex()}".upper()

def estimate_distance(rssi, measured_power, n):
    if rssi == 0:
        return -1.0
    return 10 ** ((measured_power - rssi) / (10 * n))

def decode_eddystone_url(payload_bytes_starting_with_scheme):
    url_schemes = {
        0x00: "http://www.", 0x01: "https://www.", 0x02: "http://", 0x03: "https://",
    }
    url_suffixes = {
        0x00: ".com/", 0x01: ".org/", 0x02: ".edu/", 0x03: ".net/", 0x04: ".info/",
        0x05: ".biz/", 0x06: ".gov/", 0x07: ".com", 0x08: ".org", 0x09: ".edu",
        0x0a: ".net", 0x0b: ".info", 0x0c: ".biz", 0x0d: ".gov",
    }

    if not payload_bytes_starting_with_scheme or len(payload_bytes_starting_with_scheme) < 1:
        logging.debug("BLE: decode_eddystone_url: Empty or too short payload.")
        return None

    scheme_byte = payload_bytes_starting_with_scheme[0]
    url_result = url_schemes.get(scheme_byte, "")
    if not url_result:
        logging.debug(f"BLE: decode_eddystone_url: Unknown scheme byte {hex(scheme_byte)}")
        return None

    i = 1 # Start from the byte after the scheme byte
    while i < len(payload_bytes_starting_with_scheme):
        byte_val = payload_bytes_starting_with_scheme[i]
        if byte_val in url_suffixes:
            url_result += url_suffixes[byte_val]
        else:
            start_segment = i
            while i < len(payload_bytes_starting_with_scheme) and payload_bytes_starting_with_scheme[i] not in url_suffixes:
                i += 1
            try:
                url_result += payload_bytes_starting_with_scheme[start_segment:i].decode('utf-8', errors='ignore')
            except UnicodeDecodeError:
                logging.warning(f"BLE: decode_eddystone_url: Could not decode URL segment: {payload_bytes_starting_with_scheme[start_segment:i].hex()}")
                return None
            i -= 1

        i += 1

    return url_result

# --- Display Hilfsfunktionen ---
def degrees_to_cardinal(degrees):
    directions = ["N", "NNO", "NO", "ONO", "O", "OSO", "SO", "SSO",
                  "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW"]
    idx = round(degrees / (360. / len(directions))) % len(directions)
    return directions[idx]

async def get_weather_data_async():
    global last_pws_query_time, last_successful_weather_data
    
    if time.time() - last_pws_query_time < SYSTEM_CONFIG["system_globals"]["weather_config"]["query_interval_sec"]:
        logging.info("DISP: Wetterdaten-Abfrageintervall noch nicht erreicht. Verwende letzte Daten aus Cache.")
        return last_successful_weather_data

    try:
        logging.info(f"DISP: Frage Wetterdaten von {SYSTEM_CONFIG['system_globals']['weather_config']['query_url']} ab...")
        response = await asyncio.to_thread(requests.get, SYSTEM_CONFIG["system_globals"]["weather_config"]["query_url"], timeout=10)
        response.raise_for_status()
        data = response.json()

        obs = data.get("observations", [])
        if not obs:
            logging.warning("DISP: Keine Beobachtungen in den Wetterdaten gefunden. Verwende Cache.")
            last_successful_weather_data["is_cached"] = True
            return last_successful_weather_data

        metric = obs[0].get("metric", {})
        winddir_deg = obs[0].get("winddir")
        
        weather_info = {
            "temperature": f"{metric.get('temp', 'N/A')}°C",
            "wind_direction": degrees_to_cardinal(winddir_deg) if winddir_deg is not None else "N/A",
            "wind_speed": f"{metric.get('windSpeed', 'N/A')} km/h",
            "precipitation": f"{metric.get('precipTotal', 'N/A')} mm",
            "is_cached": False
        }
        last_pws_query_time = time.time()
        last_successful_weather_data = weather_info
        logging.info(f"DISP: Wetterdaten erfolgreich abgerufen: {weather_info}")
        return weather_info

    except requests.exceptions.RequestException as e:
        logging.error(f"DISP: Fehler bei der Wetterdaten-Abfrage: {e}. Verwende Cache.")
        last_successful_weather_data["is_cached"] = True
        return last_successful_weather_data
    except json.JSONDecodeError as e:
        logging.error(f"DISP: Fehler beim Parsen der Wetterdaten (JSON): {e}. Verwende Cache.")
        last_successful_weather_data["is_cached"] = True
        return last_successful_weather_data
    except Exception as e:
        logging.error(f"DISP: Ein unerwarteter Fehler bei der Wetterdaten-Abfrage ist aufgetreten: {e}. Verwende Cache.")
        last_successful_weather_data["is_cached"] = True
        return last_successful_weather_data

def get_time_based_greeting():
    current_hour = datetime.datetime.now().hour
    if 5 <= current_hour < 11:
        return "Guten Morgen!"
    elif 11 <= current_hour < 18:
        return "Guten Tag!"
    else:
        return "Guten Abend!"

def prepare_black_icon_for_sharp_display(image_path, size):
    img = Image.open(image_path).resize(size, Image.LANCZOS)
    if img.mode != 'RGBA':
        img = img.convert('RGBA')
    background = Image.new('RGB', size, (255, 255, 255))
    background.paste(img, (0, 0), img)
    one_bit_img = background.convert('1')
    final_icon = ImageOps.invert(one_bit_img)
    return final_icon

def load_icons():
    global ICON_KEY, ICON_WIND, ICON_RAIN
    try:
        script_dir = os.path.dirname(os.path.abspath(__file__))
        key_path = os.path.join(script_dir, 'key.png')
        wind_path = os.path.join(script_dir, 'wind.png')
        rain_path = os.path.join(script_dir, 'rain.png')

        ICON_KEY = prepare_black_icon_for_sharp_display(key_path, ICON_DIMENSIONS)
        ICON_WIND = prepare_black_icon_for_sharp_display(wind_path, WEATHER_ICON_SIZE)
        ICON_RAIN = prepare_black_icon_for_sharp_display(rain_path, WEATHER_ICON_SIZE)
        logging.info(f"DISP: Icons geladen und skaliert.")

    except FileNotFoundError as e:
        logging.error(f"DISP: FEHLER: Icon-Datei nicht gefunden: {e}. Icons werden nicht angezeigt.")
        ICON_KEY = None
        ICON_WIND = None
        ICON_RAIN = None
    except Exception as e:
        logging.error(f"DISP: FEHLER beim Laden oder Skalieren der Icons: {e}. Icons werden nicht angezeigt.")
        ICON_KEY = None
        ICON_WIND = None
        ICON_RAIN = None

FONT_PATHS_TO_TRY = [
    '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf',
    '/usr/share/fonts/truetype/freefont/FreeSans.ttf'
]

def load_font_robust(size, default_font=None):
    for path in FONT_PATHS_TO_TRY:
        if os.path.exists(path):
            try:
                return ImageFont.truetype(path, size)
            except IOError:
                logging.warning(f"DISP: Konnte Schriftart {path} nicht laden. Versuche nächste.")
    logging.error("DISP: Keine der bevorzugten Schriftarten gefunden oder geladen. Verwende Standard-Font.")
    return default_font if default_font else ImageFont.load_default()

FONT_GREETING = load_font_robust(38)
FONT_TIME_DATE = load_font_robust(24)
FONT_WEATHER_TEMP_BIG = load_font_robust(42)
FONT_WEATHER_DETAIL = load_font_robust(22)

def draw_display_content(draw, weather_data, status_icon_type=None):
    BLACK = 0
    WHITE = 255

    draw.rectangle((0, 0, DISPLAY_WIDTH, DISPLAY_HEIGHT), outline=WHITE, fill=WHITE)

    current_y = 5
    PADDING_AFTER_GREETING = 5
    PADDING_AFTER_TIME_DATE = 10
    PADDING_AFTER_TEMPERATURE = 15
    PADDING_BETWEEN_WIND_RAIN = 5
    VERTICAL_TEXT_ALIGN_OFFSET = -12
    DRAW_DATE_TIME_LINE = True
    LINE_THICKNESS = 1
    PADDING_AFTER_LINE = 28
    WEATHER_BLOCK_INITIAL_OFFSET = 10

    greeting_text = get_time_based_greeting()
    draw.text((5, current_y), greeting_text, font=FONT_GREETING, fill=BLACK)
    current_y += FONT_GREETING.getbbox(greeting_text)[3] + PADDING_AFTER_GREETING

    current_time_str = time.strftime("%H:%M")
    current_date_str = time.strftime("%d.%m.%Y")
    time_date_text = f"{current_time_str} - {current_date_str}"
    draw.text((5, current_y), time_date_text, font=FONT_TIME_DATE, fill=BLACK)
    current_y += FONT_TIME_DATE.getbbox(time_date_text)[3] + PADDING_AFTER_TIME_DATE

    if DRAW_DATE_TIME_LINE:
        line_start_x = 5
        line_end_x = DISPLAY_WIDTH - 5
        draw.line([(line_start_x, current_y), (line_end_x, current_y)], fill=BLACK, width=LINE_THICKNESS)
        current_y += LINE_THICKNESS + PADDING_AFTER_LINE
    
    current_y += WEATHER_BLOCK_INITIAL_OFFSET

    if weather_data:
        temp_text = weather_data.get('temperature', 'N/A')
        if weather_data.get('is_cached', False):
            temp_text = f"[{temp_text}]"
        
        draw.text((5, current_y), temp_text, font=FONT_WEATHER_TEMP_BIG, fill=BLACK)
        current_y += FONT_WEATHER_TEMP_BIG.getbbox(temp_text)[3] + PADDING_AFTER_TEMPERATURE
        
        if ICON_WIND is not None:
            wind_icon_y = current_y
            draw.bitmap((5, wind_icon_y), ICON_WIND, fill=BLACK)
            text_height_for_centering = FONT_WEATHER_DETAIL.getbbox('')[3]
            text_y_pos = int(wind_icon_y + (WEATHER_ICON_SIZE[1] - text_height_for_centering) / 2 + VERTICAL_TEXT_ALIGN_OFFSET)
            draw.text((5 + WEATHER_ICON_SIZE[0] + 5, text_y_pos),
                      f"{weather_data.get('wind_speed', 'N/A')} -- {weather_data.get('wind_direction', 'N/A')}",
                      font=FONT_WEATHER_DETAIL, fill=BLACK)
            current_y += WEATHER_ICON_SIZE[1] + PADDING_BETWEEN_WIND_RAIN
        else:
            wind_text = f"Wind: {weather_data.get('wind_speed', 'N/A')} {weather_data.get('wind_direction', 'N/A')}"
            bbox = draw.textbbox((5, current_y), wind_text, font=FONT_WEATHER_DETAIL)
            draw.text((5, current_y), wind_text, font=FONT_WEATHER_DETAIL, fill=BLACK)
            current_y = bbox[3] + PADDING_BETWEEN_WIND_RAIN
        
        if ICON_RAIN is not None:
            rain_icon_y = current_y
            draw.bitmap((5, rain_icon_y), ICON_RAIN, fill=BLACK)
            text_height_for_centering = FONT_WEATHER_DETAIL.getbbox('')[3]
            text_y_pos = int(rain_icon_y + (WEATHER_ICON_SIZE[1] - text_height_for_centering) / 2 + VERTICAL_TEXT_ALIGN_OFFSET)
            draw.text((5 + WEATHER_ICON_SIZE[0] + 5, text_y_pos),
                      f"{weather_data.get('precipitation', 'N/A')}",
                      font=FONT_WEATHER_DETAIL, fill=BLACK)
            current_y += WEATHER_ICON_SIZE[1]
        else:
            rain_text = f"Regen: {weather_data.get('precipitation', 'N/A')}"
            bbox = draw.textbbox((5, current_y), rain_text, font=FONT_WEATHER_DETAIL)
            draw.text((5, current_y), rain_text, font=FONT_WEATHER_DETAIL, fill=BLACK)
            current_y = bbox[3]

    icon_to_draw = None
    if status_icon_type == "ACCESS_GRANTED":
        icon_to_draw = ICON_KEY
    
    if icon_to_draw:
        x_pos = DISPLAY_WIDTH - ICON_DIMENSIONS[0] - 5
        y_pos = DISPLAY_HEIGHT - ICON_DIMENSIONS[1] - 5
        draw.bitmap((x_pos, y_pos), icon_to_draw, fill=BLACK)

def toggle_extcomin():
    global extcomin_running
    logging.info("DISP: Starte manuelles EXTCOMIN Toggling.")
    while extcomin_running:
        if extcomin is not None:
            extcomin.value = not extcomin.value
        time.sleep(0.5)
    logging.info("DISP: EXTCOMIN Toggling beendet.")

# --- Asynchrone Tasks ---

# Task 1: BLE Scan
async def scan_for_ibeacons_task():
    global beacon_last_seen_data, beacon_is_present
    
    logging.info("BLE: Starte BLE-Scan nach iBeacons...")
    logging.info(f"BLE: Suche nach iBeacon UUID: {SYSTEM_CONFIG['system_globals']['ibeacon_uuid']}")

    # Collect all allowed major values from known_beacons for filtering
    allowed_majors = set()
    for beacon_cfg in SYSTEM_CONFIG["known_beacons"]:
        allowed_majors.add(beacon_cfg["ibeacon"]["major"])
    logging.info(f"BLE: Erlaubte Major-Werte für BLE-Erkennung: {allowed_majors}")


    def detection_callback(device, advertisement_data):
        current_mac = device.address
        
        # If MAC is not in our known_beacons_config, ignore it for identification purposes
        if current_mac not in beacon_identification_state:
            logging.debug(f"BLE: Unbekannter Beacon (nicht in config): MAC={current_mac}, RSSI={advertisement_data.rssi} dBm.")
            return # Skip further processing for unknown beacons

        # Get current state for this beacon
        beacon_state = beacon_identification_state[current_mac]
        beacon_config = beacon_state["known_beacon_config"]
        auth_criteria = SYSTEM_CONFIG["auth_criteria"] # Use global auth_criteria

        # Parse iBeacon data
        parsed_ibeacon = None
        if 0x004C in advertisement_data.manufacturer_data:
            mfg_data = advertisement_data.manufacturer_data[0x004C]
            if len(mfg_data) >= 23 and mfg_data[0] == 0x02 and mfg_data[1] == 0x15:
                try:
                    uuid_bytes = mfg_data[2:18] 
                    major_val = struct.unpack_from(">H", mfg_data, 18)[0]
                    minor_val = struct.unpack_from(">H", mfg_data, 20)[0]
                    
                    if bytes_to_uuid(uuid_bytes) == SYSTEM_CONFIG["system_globals"]["ibeacon_uuid"] and \
                       major_val == beacon_config["ibeacon"]["major"] and \
                       minor_val == beacon_config["ibeacon"]["minor"]:
                        parsed_ibeacon = {
                            "uuid": bytes_to_uuid(uuid_bytes),
                            "major": major_val,
                            "minor": minor_val
                        }
                    else:
                        logging.debug(f"BLE: iBeacon mismatch for {current_mac}: UUID={bytes_to_uuid(uuid_bytes)}, Major={major_val}, Minor={minor_val}")
                except struct.error as e:
                    logging.debug(f"BLE: iBeacon struct error for {current_mac}: {e}")
                except Exception as e:
                    logging.debug(f"BLE: iBeacon parsing error for {current_mac}: {e}")

        # Parse Eddystone data (UID and URL)
        parsed_eddystone_uid = None
        parsed_eddystone_url = None
        eddystone_service_uuid_str = "0000feaa-0000-1000-8000-00805f9b34fb"
        if eddystone_service_uuid_str in advertisement_data.service_data:
            eddystone_payload = advertisement_data.service_data[eddystone_service_uuid_str]
            
            logging.debug(f"BLE: Raw Eddystone Payload for {current_mac}: {eddystone_payload.hex()}")

            if eddystone_payload and len(eddystone_payload) >= 1:
                frame_type = eddystone_payload[0]
                
                if frame_type == 0x00: # UID Frame
                    if len(eddystone_payload) >= 18: # Total length including Frame Type and Ranging Data
                        namespace_id_bytes = eddystone_payload[2:12] # Corrected offset
                        instance_id_bytes = eddystone_payload[12:18] # Corrected offset
                        
                        logging.debug(f"BLE: UID Namespace from payload: {namespace_id_bytes.hex().upper()}")
                        logging.debug(f"BLE: UID Instance from payload: {instance_id_bytes.hex().upper()}")

                        if namespace_id_bytes.hex().upper() == SYSTEM_CONFIG["system_globals"]["eddystone_namespace_id"] and \
                           instance_id_bytes.hex().upper() == beacon_config["eddystone_uid"]["instance_id"]:
                            parsed_eddystone_uid = {
                                "namespace_id": namespace_id_bytes.hex().upper(),
                                "instance_id": instance_id_bytes.hex().upper()
                            }
                        else:
                            logging.debug(f"BLE: UID mismatch for {current_mac}: Expected Namespace {SYSTEM_CONFIG['system_globals']['eddystone_namespace_id']}, Instance {beacon_config['eddystone_uid']['instance_id']}, got Namespace {namespace_id_bytes.hex().upper()}, Instance {instance_id_bytes.hex().upper()}")
                    else:
                        logging.debug(f"BLE: UID payload too short for {current_mac}: {len(eddystone_payload)} bytes")
                elif frame_type == 0x10: # URL Frame
                    if len(eddystone_payload) >= 3: # Need at least Frame Type, Ranging Data, URL Scheme Prefix
                        parsed_eddystone_url = decode_eddystone_url(eddystone_payload[2:]) 
                        logging.debug(f"BLE: Parsed Eddystone URL for {current_mac}: {parsed_eddystone_url}")
                        
                        if parsed_eddystone_url and parsed_eddystone_url.lower() == beacon_config["eddystone_url"].lower():
                            pass
                        else:
                            logging.info(f"BLE: URL mismatch for {current_mac}: Expected '{beacon_config['eddystone_url']}', got '{parsed_eddystone_url}'") 
                            parsed_eddystone_url = None
                    else:
                        logging.debug(f"BLE: URL payload too short for {current_mac}: {len(eddystone_payload)} bytes")
                elif frame_type == 0x20: # TLM Frame
                    logging.debug(f"BLE: Eddystone TLM frame detected for {current_mac}. Not parsing.")
                else:
                    logging.debug(f"BLE: Unknown Eddystone Frame Type for {current_mac}: {hex(frame_type)}")
            else:
                logging.debug(f"BLE: Empty Eddystone payload for {current_mac}")

        # --- Update Beacon State ---
        if parsed_ibeacon:
            beacon_state['ibeacon_data'] = parsed_ibeacon
        if parsed_eddystone_uid:
            beacon_state['uid_data'] = parsed_eddystone_uid
        if parsed_eddystone_url:
            beacon_state['url_data'] = parsed_eddystone_url
        beacon_state['last_packet_time'] = time.time()

        # --- Check for Full Identification ---
        if not beacon_state['is_fully_identified']:
            is_match = True
            matched_criteria = []
            
            # Check iBeacon requirement
            if auth_criteria.get("ibeacon", "DISABLED") == "REQUIRED":
                if beacon_state['ibeacon_data']:
                    matched_criteria.append("iBeacon")
                else:
                    is_match = False
            elif auth_criteria.get("ibeacon", "DISABLED") == "OPTIONAL":
                if beacon_state['ibeacon_data']:
                    matched_criteria.append("iBeacon (Optional)")
            
            # Check Eddystone UID requirement
            if is_match and auth_criteria.get("eddystone_uid", "DISABLED") == "REQUIRED":
                if beacon_state['uid_data']:
                    matched_criteria.append("Eddystone UID")
                else:
                    is_match = False
            elif is_match and auth_criteria.get("eddystone_uid", "DISABLED") == "OPTIONAL":
                if beacon_state['uid_data']:
                    matched_criteria.append("Eddystone UID (Optional)")

            # Check Eddystone URL requirement
            if is_match and auth_criteria.get("eddystone_url", "DISABLED") == "REQUIRED":
                if beacon_state['url_data']:
                    matched_criteria.append("Eddystone URL")
                else:
                    is_match = False
            elif is_match and auth_criteria.get("eddystone_url", "DISABLED") == "OPTIONAL":
                if beacon_state['url_data']:
                    matched_criteria.append("Eddystone URL (Optional)")
            
            # Check MAC Address requirement
            if is_match and auth_criteria.get("mac_address", "DISABLED") == "REQUIRED":
                matched_criteria.append("MAC Address")
            elif is_match and auth_criteria.get("mac_address", "DISABLED") == "OPTIONAL":
                matched_criteria.append("MAC Address (Optional)")


            if is_match:
                beacon_state['is_fully_identified'] = True
                logging.info(f"BLE: *** Beacon '{beacon_state['name']}' ({current_mac}) VOLLSTÄNDIG IDENTIFIZIERT! Kriterien: {', '.join(matched_criteria)} ***")
            else:
                missing_criteria = []
                if auth_criteria.get("ibeacon", "DISABLED") == "REQUIRED" and not beacon_state['ibeacon_data']: missing_criteria.append("iBeacon")
                if auth_criteria.get("eddystone_uid", "DISABLED") == "REQUIRED" and not beacon_state['uid_data']: missing_criteria.append("Eddystone UID")
                if auth_criteria.get("eddystone_url", "DISABLED") == "REQUIRED" and not beacon_state['url_data']: missing_criteria.append("Eddystone URL")
                
                if missing_criteria:
                    logging.info(f"BLE: Identifikation für Beacon '{beacon_state['name']}' ({current_mac}) unvollständig. Fehlt: {', '.join(missing_criteria)}. "
                                 f"iBeacon: {'OK' if beacon_state['ibeacon_data'] else 'N/A'}, UID: {'OK' if beacon_state['uid_data'] else 'N/A'}, URL: {'OK' if beacon_state['url_data'] else 'N/A'}")
                else:
                    logging.debug(f"BLE: Beacon '{beacon_state['name']}' ({current_mac}) not fully identified, but no REQUIRED criteria missing. Check logic.")

    scanner = BleakScanner(detection_callback=detection_callback)
    await scanner.start()
    
    try:
        while True: # Changed from while ble_scan_active to allow graceful shutdown
            current_time = time.time()
            # Cleanup/Timeout for identification state
            beacons_to_remove = []
            for mac, state in beacon_identification_state.items():
                if current_time - state['last_packet_time'] > SYSTEM_CONFIG["system_globals"]["identification_timeout_sec"]:
                    if not state['is_fully_identified']:
                        logging.info(f"BLE: Identifikation für Beacon '{state['name']}' ({mac}) abgelaufen. Nicht vollständig identifiziert.")
                    beacons_to_remove.append(mac)
            
            for mac in beacons_to_remove:
                del beacon_identification_state[mac]
                # Re-initialize the state for this beacon if it's a known beacon from config
                # This ensures it can be re-identified if it comes back into range
                for beacon_cfg in SYSTEM_CONFIG["known_beacons"]:
                    if beacon_cfg.get("mac_address") == mac:
                        beacon_identification_state[mac] = {
                            "name": beacon_cfg.get("name", "Unbekannt"),
                            "is_allowed": beacon_cfg.get("is_allowed", False),
                            "ibeacon_data": None,
                            "uid_data": None,
                            "url_data": None,
                            "last_packet_time": current_time,
                            "is_fully_identified": False,
                            "known_beacon_config": beacon_cfg
                        }
                        break

            await asyncio.sleep(SYSTEM_CONFIG["system_globals"]["ble_scan_interval_sec"])
    except asyncio.CancelledError:
        logging.info("BLE: Scan-Loop abgebrochen.")
    finally:
        # Ensure scanner is stopped even if loop is cancelled
        await scanner.stop()
        logging.info("BLE: Scanner gestoppt.")

# Task 2: Display Management
async def display_manager_task():
    # Farben innerhalb der Funktion definieren, um Scope-Probleme zu vermeiden
    BLACK = 0
    WHITE = 255

    load_icons()

    spi = busio.SPI(board.SCK, MOSI=board.MOSI)
    
    global cs, extcomin, disp, extcomin_running
    cs = digitalio.DigitalInOut(SHARP_CS_PIN)
    extcomin = digitalio.DigitalInOut(SHARP_EXTCOMIN_PIN)
    disp = digitalio.DigitalInOut(SHARP_DISP_PIN)

    cs.direction = digitalio.Direction.OUTPUT
    extcomin.direction = digitalio.Direction.OUTPUT
    disp.direction = digitalio.Direction.OUTPUT

    disp.value = True
    extcomin.value = False

    extcomin_running = True
    extcomin_thread_task = asyncio.create_task(asyncio.to_thread(toggle_extcomin))
    logging.info("DISP: Starte manuelles EXTCOMIN Toggling.")
    await asyncio.sleep(0.1)

    global display
    try:
        display = adafruit_sharpmemorydisplay.SharpMemoryDisplay(
            spi, cs, DISPLAY_WIDTH, DISPLAY_HEIGHT
        )
        logging.info("DISP: Adafruit Sharp Memory Display initialisiert.")

        image = Image.new("1", (display.width, display.height))
        draw = ImageDraw.Draw(image)

        current_display_status_icon = None
        status_icon_display_until = 0

        last_weather_update_time = 0

        while True:
            current_time = time.time()
            if current_time - last_weather_update_time >= SYSTEM_CONFIG["system_globals"]["weather_config"]["query_interval_sec"]:
                weather_data = await get_weather_data_async()
                last_weather_update_time = current_time
            else:
                weather_data = last_successful_weather_data

            try:
                message = display_status_queue.get_nowait()
                if message["type"] == "status":
                    current_display_status_icon = message["value"]
                    status_icon_display_until = current_time + message.get("duration", 0)
                    logging.info(f"DISP: Status-Update: {current_display_status_icon} für {message.get('duration', 0)}s")
            except asyncio.QueueEmpty:
                pass

            if current_display_status_icon and current_time > status_icon_display_until:
                current_display_status_icon = None
                logging.info("DISP: Status-Icon ausgeblendet.")

            draw_display_content(draw, weather_data, status_icon_type=current_display_status_icon)
            display.image(image)
            display.show()

            await asyncio.sleep(0.5)

    except Exception as e:
        logging.error(f"DISP: Ein unerwarteter Fehler im Display-Manager ist aufgetreten: {e}", exc_info=True)
    finally:
        extcomin_running = False
        if extcomin_thread_task:
            extcomin_thread_task.cancel()
            try:
                await extcomin_thread_task
            except asyncio.CancelledError:
                pass
        logging.info("DISP: EXTCOMIN Toggling Thread beendet.")

        if display is not None:
            display.fill(1)
            display.show()
            logging.info("DISP: Adafruit Sharp Display gelöscht.")
            await asyncio.sleep(0.5)
        
        if cs is not None:
            cs.deinit()
            logging.info("DISP: CS Pin deinitialisiert.")
        if extcomin is not None:
            extcomin.deinit()
            logging.info("DISP: EXTCOMIN Pin deinitialisiert.")
        if disp is not None:
            disp.deinit()
            logging.info("DISP: DISP Pin deinitialisiert.")
        logging.info("DISP: Display-Manager beendet und GPIOs deinitialisiert.")

# --- Haupt-Asynchrone Funktion ---
async def main():
    global SYSTEM_CONFIG, beacon_is_present, last_door_opened_timestamp # Access global config and state

    # Load system_config.json
    loaded_config = read_system_config()
    if not loaded_config:
        logging.critical("MAIN: System konnte nicht gestartet werden, Konfiguration fehlt oder ist fehlerhaft.")
        return

    # Assign loaded config to global SYSTEM_CONFIG
    SYSTEM_CONFIG = loaded_config

    # Configure logging based on system_config.json
    logging_config = SYSTEM_CONFIG["system_globals"].get("logging_config", {})
    log_level_str = logging_config.get("level", "INFO").upper()
    log_level = getattr(logging, log_level_str, logging.INFO)
    
    # Clear existing handlers to reconfigure
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)
    
    handlers = [logging.StreamHandler()]
    if logging_config.get("file_enabled", False):
        log_file_path = logging_config.get("file_path", "tuer_oeffner.log")
        handlers.append(logging.FileHandler(log_file_path))

    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(levelname)s - %(message)s', # Removed component prefix as it's now in message
        handlers=handlers
    )
    logging.info(f"MAIN: Logging-Level auf {log_level_str} gesetzt.")

    # Initialize weather query URL with API Key from config
    SYSTEM_CONFIG["system_globals"]["weather_config"]["query_url"] = \
        f"https://api.weather.com/v2/pws/observations/current?stationId={SYSTEM_CONFIG['system_globals']['weather_config']['station_id']}&format=json&units=m&numericPrecision=decimal&apiKey={SYSTEM_CONFIG['system_globals']['weather_config']['api_key']}"


    # Pre-fill beacon_identification_state with known beacons from config
    current_time_for_init = time.time() 
    for beacon_cfg in SYSTEM_CONFIG["known_beacons"]:
        mac_addr = beacon_cfg.get("mac_address")
        if mac_addr:
            beacon_identification_state[mac_addr] = {
                "name": beacon_cfg.get("name", "Unbekannt"),
                "is_allowed": beacon_cfg.get("is_allowed", False),
                "ibeacon_data": None,
                "uid_data": None,
                "url_data": None,
                "last_packet_time": current_time_for_init, 
                "is_fully_identified": False,
                "known_beacon_config": beacon_cfg # Store full config for comparison
            }
    
    logging.info("MAIN: Türöffnungssystem gestartet.")
    logging.info(f"MAIN: System iBeacon UUID: {SYSTEM_CONFIG['system_globals']['ibeacon_uuid']}")
    logging.info(f"MAIN: System Eddystone Namespace ID: {SYSTEM_CONFIG['system_globals']['eddystone_namespace_id']}")
    logging.info(f"MAIN: Bekannte Beacons zur Identifikation: {', '.join([s['name'] for s in SYSTEM_CONFIG['known_beacons']])}")


    # Starte die asynchronen Tasks
    ble_task = asyncio.create_task(scan_for_ibeacons_task())
    display_task = asyncio.create_task(display_manager_task())

    # Haupt-Loop für die Zustandsverwaltung (Debouncing für Anwesenheit/Abwesenheit)
    last_beacon_state_change_time = time.time()
    current_beacon_state_raw = False # True, wenn irgendein relevanter Beacon gerade gesehen wird

    try:
        while True:
            current_time = time.time()
            
            # Überprüfe, ob aktuell relevante Beacons in Reichweite sind
            any_relevant_beacon_in_proximity = False
            
            # Cleanup/Timeout for identification state (copied from Beacon_Identifier_Test.py)
            beacons_to_remove = []
            for mac, state in beacon_identification_state.items():
                if current_time - state['last_packet_time'] > SYSTEM_CONFIG["system_globals"]["identification_timeout_sec"]:
                    if not state['is_fully_identified']:
                        logging.info(f"MAIN: Identifikation für Beacon '{state['name']}' ({mac}) abgelaufen. Nicht vollständig identifiziert.")
                    beacons_to_remove.append(mac)
            
            for mac in beacons_to_remove:
                del beacon_identification_state[mac]
                # Re-initialize the state for this beacon if it's a known beacon from config
                # This ensures it can be re-identified if it comes back into range
                for beacon_cfg in SYSTEM_CONFIG["known_beacons"]:
                    if beacon_cfg.get("mac_address") == mac:
                        beacon_identification_state[mac] = {
                            "name": beacon_cfg.get("name", "Unbekannt"),
                            "is_allowed": beacon_cfg.get("is_allowed", False),
                            "ibeacon_data": None,
                            "uid_data": None,
                            "url_data": None,
                            "last_packet_time": current_time,
                            "is_fully_identified": False,
                            "known_beacon_config": beacon_cfg
                        }
                        break

            # Check for fully identified and allowed beacons
            for mac, state in beacon_identification_state.items():
                if state['is_fully_identified'] and state['is_allowed']:
                    # Trigger door open command
                    logging.info(f"MAIN: Berechtigter Beacon '{state['name']}' ({mac}) vollständig identifiziert. Öffne Tür.")
                    await send_door_open_command(SYSTEM_CONFIG["system_globals"]["relay_activation_duration_sec"])
                    await display_status_queue.put({"type": "status", "value": "ACCESS_GRANTED", "duration": 5})
                    
                    last_door_opened_timestamp = current_time # Start cooldown for door opening
                    state['is_fully_identified'] = False # Reset for this beacon to prevent re-triggering
                    
                    # Also reset its identification state after successful access to avoid immediate re-trigger
                    # and force a re-identification cycle.
                    beacon_identification_state[mac] = {
                        "name": state["name"],
                        "is_allowed": state["is_allowed"],
                        "ibeacon_data": None,
                        "uid_data": None,
                        "url_data": None,
                        "last_packet_time": current_time,
                        "is_fully_identified": False,
                        "known_beacon_config": state["known_beacon_config"]
                    }
                    
                    # If any allowed beacon is identified, we are "present"
                    any_relevant_beacon_in_proximity = True # Set to true if any allowed beacon is identified

            # Debouncing for overall beacon presence (for display logic, etc.)
            # This logic might need refinement if multiple beacons are present and some leave.
            # For now, it means "at least one relevant beacon is present".
            active_known_beacons_in_range = [
                mac for mac, state in beacon_identification_state.items()
                if current_time - state['last_packet_time'] < SYSTEM_CONFIG["system_globals"]["absence_detection_time"]
            ]
            current_beacon_state_raw = len(active_known_beacons_in_range) > 0

            # Apply debouncing for beacon_is_present
            if current_beacon_state_raw and not beacon_is_present:
                if (current_time - last_beacon_state_change_time) >= SYSTEM_CONFIG["system_globals"]["presence_detection_time"]:
                    beacon_is_present = True
                    logging.info(f"MAIN: *** BEACON STABIL ANWESEND. ***")
            elif not current_beacon_state_raw and beacon_is_present:
                if (current_time - last_beacon_state_change_time) >= SYSTEM_CONFIG["system_globals"]["absence_detection_time"]:
                    beacon_is_present = False
                    logging.info(f"MAIN: --- BEACON STABIL ABWESEND. ---")

            # Enforce beacon absence after door opened (cooldown)
            if (current_time - last_door_opened_timestamp) < SYSTEM_CONFIG["system_globals"]["force_beacon_absence_duration_sec"]:
                if beacon_is_present:
                    logging.info(f"MAIN: Erzwinge Beacon-Abwesenheit für {SYSTEM_CONFIG['system_globals']['force_beacon_absence_duration_sec']}s (Cooldown nach Türöffnung).")
                beacon_is_present = False # Force to false during cooldown

            await asyncio.sleep(0.5) # Kurze Pause für den Haupt-Loop

    except asyncio.CancelledError:
        logging.info("MAIN: System-Tasks werden beendet.")
    except Exception as e:
        logging.critical(f"MAIN: Ein kritischer Fehler ist aufgetreten: {e}", exc_info=True)
    finally:
        # Sicherstellen, dass alle Tasks abgebrochen und Ressourcen freigegeben werden
        logging.info("MAIN: Starte Cleanup der Asyncio-Tasks...")
        ble_task.cancel()
        display_task.cancel()
        
        # Corrected: Wait for tasks to actually complete cancellation
        try:
            await asyncio.gather(ble_task, display_task, return_exceptions=True)
            logging.info("MAIN: Alle Asyncio-Tasks beendet.")
        except asyncio.CancelledError:
            logging.info("MAIN: Asyncio-Tasks erfolgreich abgebrochen.")
        except Exception as e:
            logging.error(f"MAIN: Fehler beim Beenden der Asyncio-Tasks: {e}")

        # Final cleanup actions
        logging.info("MAIN: Alle System-Tasks beendet.")

# --- Hauptausführung ---
if __name__ == "__main__":
    import multiprocessing
    multiprocessing.set_start_method('spawn', True) # force=True can cause issues if already set

    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logging.info("MAIN: Programm beendet durch Benutzer (Strg+C).")
        # No need to set ble_scan_active = False here, as the main loop's try/finally handles it.
        # time.sleep(1) is also not needed here.
    except Exception as e:
        logging.critical(f"MAIN: Ein kritischer Fehler ist aufgetreten: {e}", exc_info=True)
    finally:
        # cleanup_gpio() is registered with atexit, so it will be called automatically.
        logging.info("MAIN: Programm beendet.")