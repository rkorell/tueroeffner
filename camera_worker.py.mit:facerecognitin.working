# Program: camera_worker.py
# Purpose: Separater Prozess für Kamera- und Gesichtserkennung.
#          Kommuniziert mit dem Hauptprozess über Queues.
# Author: CircuIT
# Creation Date: August 15, 2025
# Modified: August 15, 2025 - Integration of Picamera2, face_recognition, and codesend logic
# Corrected: August 15, 2025 - Removed codesend call, now sends FACE_MATCH_CONFIRMED status
# Corrected: August 15, 2025 - Moved Picamera2 import inside camera_worker_process_function to avoid resource busy error
# Corrected: August 15, 2025 - Added extensive debug logging for face recognition process
# Corrected: August 15, 2025 - Moved face_recognition import to global scope for performance, stop scan after match

import logging
import time
import os
import sys
import multiprocessing
import pickle # Für das Laden der Encodings
import numpy as np # Für face_recognition
import cv2 # Für cv2.resize

# NEU: face_recognition Import auf globaler Ebene für den Worker-Prozess (einmalige Initialisierung)
import face_recognition 

# Picamera2 Imports (will be imported inside camera_worker_process_function)
# from picamera2 import Picamera2
# from libcamera import controls

# subprocess import removed as codesend is no longer called directly here
# import subprocess

# Konfiguriere Logging für diesen Worker-Prozess, um seine Ausgaben zu sehen
logging.basicConfig(level=logging.INFO, format='%(asctime)s - CAMERA_WORKER - %(levelname)s - %(message)s')

# Helper function to run face recognition (will be called within the worker process)
# face_recognition is now imported globally in this file, so it's available here.
def _run_face_recognition_core(small_frame, known_face_encodings, known_face_names_list):
    # logging.info("Kamera-Worker: Starte face_recognition.face_locations...") # Debug-Log entfernt, da zu viele Ausgaben
    face_locations = face_recognition.face_locations(small_frame, model="hog")
    # logging.info(f"Kamera-Worker: {len(face_locations)} Gesichter gefunden.") # Debug-Log entfernt, da zu viele Ausgaben
    
    if len(face_locations) == 0:
        return [] # Keine Gesichter gefunden, nichts zu tun

    # logging.info("Kamera-Worker: Starte face_recognition.face_encodings...") # Debug-Log entfernt, da zu viele Ausgaben
    face_encodings = face_recognition.face_encodings(small_frame, face_locations)
    # logging.info(f"Kamera-Worker: {len(face_encodings)} Encodings erstellt.") # Debug-Log entfernt, da zu viele Ausgaben
    
    results = []
    for i, face_encoding in enumerate(face_encodings):
        # logging.info(f"Kamera-Worker: Verarbeite Encoding {i+1}/{len(face_encodings)}...") # Debug-Log entfernt, da zu viele Ausgaben
        face_distances = face_recognition.face_distance(known_face_encodings, face_encoding)
        best_match_index = np.argmin(face_distances)
        
        name = "Unbekannt"
        if face_distances[best_match_index] <= 0.6: # Direkte Prüfung der Toleranz
            name = known_face_names_list[best_match_index]
            logging.info(f"Kamera-Worker: Bestes Match gefunden: {name} mit Distanz {face_distances[best_match_index]:.2f}")
        else:
            # logging.info(f"Kamera-Worker: Kein Match gefunden, Distanz {face_distances[best_match_index]:.2f} > 0.6") # Debug-Log entfernt, da zu viele Ausgaben
            pass # Nichts tun, wenn kein Match

        results.append({
            "name": name,
            "face_location": face_locations[i] # Use original index for location
        })
    
    return results

def camera_worker_process_function(command_queue, result_queue, initial_config):
    """
    Diese Funktion wird als separater Prozess ausgeführt.
    Sie empfängt Befehle über command_queue und sendet Ergebnisse über result_queue.
    initial_config enthält die einmalig benötigten Konfigurationsdaten.
    """
    # Import Picamera2 and libcamera.controls here, inside the function,
    # so they are initialized within the worker process when needed.
    from picamera2 import Picamera2
    from libcamera import controls

    logging.info("Kamera-Worker-Prozess gestartet.")

    # Konfiguration entpacken
    encodings_file = initial_config['encodings_file']
    allowed_users_data = initial_config['allowed_users_data']
    camera_resolution = initial_config['camera_resolution']
    frame_resize_factor = initial_config['frame_resize_factor']
    min_detection_interval = initial_config['min_detection_interval']
    set_autofocus = initial_config['set_autofocus']
    camera_debug = initial_config['camera_debug']

    # Lade die bekannten Gesichts-Encodings und Namen (jetzt im Worker-Prozess)
    known_face_encodings = []
    known_face_names = []
    try:
        logging.info(f"Kamera-Worker: Lade Gesichts-Encodings von '{encodings_file}'...")
        with open(encodings_file, 'rb') as f:
            known_face_encodings, known_face_names = pickle.load(f)
        logging.info(f"Kamera-Worker: {len(known_face_encodings)} Encodings von {len(set(known_face_names))} Personen geladen.")
    except FileNotFoundError:
        logging.error(f"Kamera-Worker: Fehler: Die Datei '{encodings_file}' wurde nicht gefunden.")
        result_queue.put({"status": "ERROR", "message": f"Encodings-Datei '{encodings_file}' nicht gefunden."})
        return # Worker beenden
    except Exception as e:
        logging.error(f"Kamera-Worker: Fehler beim Laden der Encodings: {e}")
        result_queue.put({"status": "ERROR", "message": f"Fehler beim Laden der Encodings: {e}"})
        return # Worker beenden

    picam2 = None
    camera_is_running_in_worker = False
    last_recognition_time = 0 # Für MIN_DETECTION_INTERVAL

    try:
        while True: # Äußere Schleife: Wartet auf Befehle
            # Prüfe auf Befehle vom Hauptprozess (nicht-blockierend, damit Schleife weiterläuft)
            try:
                command_message = command_queue.get_nowait()
                command = command_message.get("command")
                logging.info(f"Kamera-Worker: Befehl erhalten: {command}")

                if command == "START_CAMERA":
                    expected_names = command_message.get("expected_names", [])
                    logging.info(f"Kamera-Worker: Befehl START_CAMERA erhalten. Erwartete Namen: {expected_names}")
                    
                    if not camera_is_running_in_worker:
                        # Kamera initialisieren und starten
                        picam2 = Picamera2()
                        camera_config = picam2.create_video_configuration(main={"size": camera_resolution, "format": "RGB888"})
                        picam2.configure(camera_config)
                        picam2.start()
                        time.sleep(1) # Wartezeit für Kamera-Bereitschaft
                        if set_autofocus:
                            picam2.set_controls({"AfMode": 2}) # Numerischer Wert für Continuous Autofocus
                        camera_is_running_in_worker = True
                        logging.info("Kamera-Worker: Kamera physisch gestartet.")
                    
                    result_queue.put({"status": "CAMERA_STARTED"})
                    logging.info("Kamera-Worker: CAMERA_STARTED gesendet.")
                    
                    # Haupt-Loop für Frame-Erfassung und Gesichtserkennung
                    # Loop läuft, solange Kamera aktiv ist und kein Match gefunden wurde ODER min_detection_interval nicht abgelaufen ist
                    match_found_and_reported = False
                    while camera_is_running_in_worker and not match_found_and_reported:
                        # Prüfe erneut auf STOP/TERMINATE Befehle, damit wir die Schleife verlassen können
                        try:
                            next_command_message = command_queue.get_nowait()
                            next_command = next_command_message.get("command")
                            if next_command == "STOP_CAMERA":
                                logging.info("Kamera-Worker: STOP_CAMERA Befehl während des Betriebs erhalten.")
                                break # Beende den inneren Loop
                            elif next_command == "TERMINATE":
                                logging.info("Kamera-Worker: TERMINATE Befehl während des Betriebs erhalten.")
                                raise SystemExit # Beende den Worker komplett
                        except multiprocessing.queues.Empty:
                            pass # Kein neuer Befehl, weiter mit Frame

                        # logging.info("Kamera-Worker: Erfasse Frame...") # Debug-Log entfernt, da zu viele Ausgaben
                        frame = picam2.capture_array() # Frame erfassen
                        # logging.info("Kamera-Worker: Frame erfasst. Skaliere...") # Debug-Log entfernt, da zu viele Ausgaben
                        small_frame = cv2.resize(frame, (0, 0), fx=frame_resize_factor, fy=frame_resize_factor)
                        
                        # Führe Gesichtserkennung aus
                        recognition_results = _run_face_recognition_core(small_frame, known_face_encodings, known_face_names)
                        
                        if not recognition_results: # Keine Gesichter im Frame gefunden
                            # logging.info("Kamera-Worker: Keine Gesichter im Frame gefunden.") # Debug-Log entfernt, da zu viele Ausgaben
                            pass # Nichts tun, wenn keine Gesichter gefunden
                        else:
                            for result in recognition_results:
                                identified_name = result['name']
                                
                                # Überprüfe, ob die Person in der Konfiguration erlaubt ist
                                is_allowed_in_config = allowed_users_data.get(identified_name, {}).get('allowed', False)

                                # Überprüfe die "Gesicht-Beacon Übereinstimmung" und Konfigurationserlaubnis
                                if identified_name in expected_names and is_allowed_in_config:
                                    if (time.time() - last_recognition_time) > min_detection_interval:
                                        logging.info(f"Kamera-Worker: *** Person erkannt: {identified_name}. Match bestätigt. Melde an Hauptprozess. ***")
                                        # Sende Bestätigung an Hauptprozess, DASS ein Match gefunden wurde
                                        result_queue.put({"status": "FACE_MATCH_CONFIRMED", "name": identified_name})
                                        last_recognition_time = time.time()
                                        match_found_and_reported = True # Setze Flag, um Loop zu verlassen
                                        break # Verlasse die Schleife über die Ergebnisse, da Match gefunden
                                    else:
                                        logging.info(f"Kamera-Worker: Person {identified_name} erkannt, aber MIN_DETECTION_INTERVAL noch nicht abgelaufen.")
                                else: # Person ist unbekannt oder nicht erwartet/erlaubt
                                    if identified_name != "Unbekannt":
                                        if not is_allowed_in_config:
                                            logging.warning(f"Kamera-Worker: Person erkannt: {identified_name}. Aber nicht in Konfiguration erlaubt. Zugang verweigert.")
                                            result_queue.put({"status": "NO_FACE_MATCH", "reason": "NotAllowedInConfig", "name": identified_name})
                                        elif identified_name not in expected_names:
                                            logging.warning(f"Kamera-Worker: Person erkannt: {identified_name}. Aber nicht unter erwarteten Namen ({expected_names}). Zugang verweigert.")
                                            result_queue.put({"status": "NO_FACE_MATCH", "reason": "NotExpected", "name": identified_name})
                                    else:
                                        # logging.info(f"Kamera-Worker: Unbekanntes Gesicht erkannt.") # Debug-Log entfernt, da zu viele Ausgaben
                                        result_queue.put({"status": "NO_FACE_MATCH", "reason": "Unknown", "name": identified_name})

                        # Kurze Pause, um CPU zu entlasten und die Schleife nicht zu schnell laufen zu lassen
                        time.sleep(0.1) # 100ms Pause zwischen Frames
                    
                    # NEU: Wenn match_found_and_reported == True, sind wir hierher gekommen,
                    # also brechen wir die innere Schleife ab und stoppen die Kamera.
                    if match_found_and_reported:
                        logging.info("Kamera-Worker: Match gefunden und gemeldet. Stoppe Kamera.")
                        if camera_is_running_in_worker:
                            picam2.stop()
                            picam2 = None # Objekt freigeben
                            camera_is_running_in_worker = False
                            logging.info("Kamera-Worker: Kamera physisch gestoppt.")
                        result_queue.put({"status": "CAMERA_STOPPED"})
                        logging.info("Kamera-Worker: CAMERA_STOPPED gesendet.")
                        # Nach dem Stoppen der Kamera kehren wir zur äußeren Schleife zurück und warten auf neue Befehle.


                elif command == "STOP_CAMERA":
                    logging.info("Kamera-Worker: Befehl STOP_CAMERA erhalten.")
                    if camera_is_running_in_worker:
                        picam2.stop()
                        picam2 = None # Objekt freigeben
                        camera_is_running_in_worker = False
                        logging.info("Kamera-Worker: Kamera physisch gestoppt.")
                    result_queue.put({"status": "CAMERA_STOPPED"})
                    logging.info("Kamera-Worker: CAMERA_STOPPED gesendet.")

                elif command == "TERMINATE":
                    logging.info("Kamera-Worker: Befehl TERMINATE erhalten. Beende Prozess.")
                    raise SystemExit # Beende den Worker komplett

                else:
                    logging.warning(f"Kamera-Worker: Unbekannter Befehl: {command}")

            except multiprocessing.queues.Empty:
                # Kein Befehl erhalten, Worker wartet auf nächsten Befehl
                time.sleep(0.5) # Kurze Pause, um CPU zu entlasten
            
    except SystemExit: # Sauberes Beenden durch TERMINATE Befehl
        logging.info("Kamera-Worker: SystemExit ausgelöst, beende sauber.")
    except Exception as e:
        logging.error(f"Kamera-Worker: Ein unerwarteter Fehler ist aufgetreten: {e}", exc_info=True)
        result_queue.put({"status": "ERROR", "message": f"Worker-Fehler: {e}"})
    finally:
        if camera_is_running_in_worker and picam2:
            picam2.stop()
            logging.info("Kamera-Worker: Kamera im finally gestoppt.")
        logging.info("Kamera-Worker-Prozess beendet.")

if __name__ == '__main__':
    # Dieser Block wird nur ausgeführt, wenn camera_worker.py direkt gestartet wird,
    # nicht wenn es als Prozess von tueroeffner.py gestartet wird.
    # Nützlich für isolierte Tests.
    print("Dies ist der camera_worker.py. Er sollte normalerweise nicht direkt ausgeführt werden.")
    print("Er wird als separater Prozess von tueroeffner.py gestartet.")
    print("Für einen Test können Sie hier eine Dummy-Kommunikation einrichten.")
    # Beispiel für einen Dummy-Test:
    # from multiprocessing import Queue
    # cmd_q = Queue()
    # res_q = Queue()
    # # Dummy-Konfiguration
    # dummy_config = {
    #     'encodings_file': 'encodings.pkl', # Muss existieren für Test
    #     'allowed_users_data': {'Ralf': {'allowed': True, 'beacon_majors': [3112]}},
    #     'camera_resolution': (640, 480),
    #     'frame_resize_factor': 0.25,
    #     'min_detection_interval': 5,
    #     'codesend_path': '/usr/local/bin/codesend',
    #     'codesend_code_basis': 9128374,
    #     'codesend_min_duration_sec': 3,
    #     'relay_activation_duration_sec': 4,
    #     'set_autofocus': True,
    #     'camera_debug': True
    # }
    # worker_process = multiprocessing.Process(target=camera_worker_process_function, args=(cmd_q, res_q, dummy_config))
    # worker_process.start()
    # cmd_q.put({"command": "START_CAMERA", "expected_names": ["Ralf"]})
    # print(res_q.get()) # Should print CAMERA_STARTED
    # # Warten auf Erkennungsergebnisse
    # time.sleep(10) # Genug Zeit für Kamera und Erkennung
    # cmd_q.put({"command": "STOP_CAMERA"})
    # print(res_q.get()) # Should print CAMERA_STOPPED
    # cmd_q.put({"command": "TERMINATE"})
    # worker_process.join()
    # print("Dummy-Test beendet.")